CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: standard-vs
      frag: standard-fs
      embeddedMacros: { CC_DRAW_DIFFUSE: true, CC_DRAW_SPECULAR: false, CC_SURFACES_LIGHTING_DISABLE_DIFFUSE: true, CC_SURFACES_LIGHTING_DISABLE_SPECULAR: true }
      properties: &props
        tilingOffset:                     { value: [1.0, 1.0, 0.0, 0.0] }
        mainColor:                        { value: [1.0, 1.0, 1.0, 1.0], target: albedo, linear: true, editor: { displayName: Albedo, type: color } }
        albedoScale:                      { value: [1.0, 1.0, 1.0], target: albedoScaleAndCutoff.xyz }
        alphaThreshold:                   { value: 0.5, target: albedoScaleAndCutoff.w, editor: { parent: USE_ALPHA_TEST, slide: true, range: [0, 1.0], step: 0.001 } }
        occlusion:                        { value: 0.0, target: pbrParams.x, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        roughness:                        { value: 0.25, target: pbrParams.y, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        specularIntensity:                { value: 0.5, target: pbrParams.w, editor: { slide: true, range: [0.0, 1.0], step: 0.001 } }
        normalStrength:                   { value: 1.0, target: emissiveScaleParam.w, editor: { parent: USE_NORMAL_MAP, slide: true, range: [0, 5.0], step: 0.001 } }
        mainTexture:                      { value: grey, target: albedoMap, editor: { displayName: AlbedoMap } }
        normalMap:                        { value: normal }
        pbrMap:                           { value: grey, editor: { displayName: PbrOrRoughnessMap } }
        occlusionMap:                     { value: white }
        modelExtent:                      { value: 0.0, target: dualLobeParams.z, editor: { visible: false, displayName: Model Extent, min: 0, tooltip: 'The extent of the model in world space (extra range included), please use SSSModelExtentCalculator component to calculate this value automatically' } }
        scatteringProfile:                { value: 1.0, target: scatterParams.z, editor: { visible: false, displayName: Scattering Profile, slide: true, range: [1, 3], step: 1 } }
        subsurfaceMap:                    { value: white, editor: { parent: USE_SUBSURFACE_MAP, displayName: Subsurface Map, tooltip: 'R=Scatter intensity, G=Cavity' } }
        scatteringFactor:                 { value: 0.5, target: scatterParams.w, editor: { displayName: Scattering Factor, slide: true, range: [0, 1], step: 0.001 } }
        thicknessFactor:                  { value: 0.5, target: scatterParams.x, editor: { displayName: Thickness Factor, slide: true, range: [0, 1], step: 0.001 } }
        thicknessMap:                     { value: white, editor: { parent: USE_THICKNESS_MAP, displayName: Thickness Map } }
        translucencyFactor:               { value: 1.0, target: scatterParams.y, editor: { displayName: Translucency Intensity, slide: true, range: [0, 3], step: 0.01, tooltip: 'Artistic intensity multiplier for translucency effect' } }
        translucencyColor:                { value: [1.0, 0.64, 0.58, 1.0], target: translucencyColor, linear: true, editor: { visible: false, displayName: Translucency Scatter Color, type: color } }
        dualLobeRoughness:                { value: 0.5, target: dualLobeParams.x, editor: { parent: USE_DUAL_LOBE_SPECULAR, range: [0, 1.0], slide: true, step: 0.001 } }
        dualLobeIntensity:                { value: 0.02, target: dualLobeParams.w, editor: { parent: USE_DUAL_LOBE_SPECULAR, slide: true, range: [0, 0.1], step: 0.001 } }
      rasterizerState: &r1
        cullMode: None
      depthStencilState: &d1
        depthFunc: less_equal
        depthTest: true
        depthWrite: true

    - vert: standard-prepass-vs
      frag: standard-prepass-fs
      phase: prepass
      embeddedMacros: { CC_SURFACES_LIGHTING_DISABLE_DIFFUSE: true, CC_SURFACES_LIGHTING_DISABLE_SPECULAR: true }
      propertyIndex: 0
      depthStencilState:
        depthFunc: less_equal
        depthTest: true
        depthWrite: true
        
    - vert: standard-vs
      frag: standard-fs
      phase: forward-add
      propertyIndex: 0
      embeddedMacros: { CC_DRAW_DIFFUSE: true, CC_DRAW_SPECULAR: false, CC_FORWARD_ADD: true, CC_SURFACES_LIGHTING_DISABLE_DIFFUSE: true, CC_SURFACES_LIGHTING_DISABLE_SPECULAR: true }
      depthStencilState:
        depthFunc: equal
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: one
          blendDst: one
          blendSrcAlpha: zero
          blendDstAlpha: one

    - vert: shadow-caster-vs
      frag: shadow-caster-fs
      phase: shadow-caster
      propertyIndex: 0
      rasterizerState:
        cullMode: none
      properties:
        tilingOffset:   { value: [1.0, 1.0, 0.0, 0.0] }
        mainColor:      { value: [1.0, 1.0, 1.0, 1.0], target: albedo, editor: { displayName: Albedo, type: color } }
        albedoScale:    { value: [1.0, 1.0, 1.0], target: albedoScaleAndCutoff.xyz }
        alphaThreshold: { value: 0.5, target: albedoScaleAndCutoff.w, editor: { parent: USE_ALPHA_TEST } }
        mainTexture:    { value: grey, target: albedoMap, editor: { displayName: AlbedoMap } }

    - vert: standard-vs
      frag: standard-fs
      phase: specular-pass
      propertyIndex: 0
      embeddedMacros: { CC_DRAW_DIFFUSE: false, CC_DRAW_SPECULAR: true, CC_SURFACES_LIGHTING_DISABLE_DIFFUSE: true, CC_SURFACES_LIGHTING_DISABLE_SPECULAR: true }
      depthStencilState:
        depthFunc: equal
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: one
          blendDst: one
          blendSrcAlpha: zero
          blendDstAlpha: one
}%

CCProgram shared-ubos %{
  uniform Constants {
    vec4 tilingOffset;
    vec4 albedo;
    vec4 albedoScaleAndCutoff;
    vec4 pbrParams;
    vec4 emissiveScaleParam;
    vec4 translucencyColor;
    vec4 scatterParams;   // x: thicknessFactor, y: translucencyFactor, z: scatteringProfile, w: scatteringFactor
    vec4 dualLobeParams;  // x: dualLobeRoughness, y: unused, z: modelExtent, w: dualLobeIntensity
  };
}%

CCProgram macro-remapping %{
  #pragma define-meta HAS_SECOND_UV
  #pragma define-meta USE_TWOSIDE
  #pragma define-meta USE_VERTEX_COLOR
  #pragma define-meta USE_DUAL_LOBE_SPECULAR
  #pragma define-meta USE_SUBSURFACE_MAP
  #pragma define-meta USE_THICKNESS_MAP
  
  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV
  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE
  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR
  #pragma CC_USE_SSS 1

  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR USE_DUAL_LOBE_SPECULAR

#if USE_NORMAL_MAP
  #define CC_SURFACES_USE_TANGENT_SPACE 1
#endif
}%

CCProgram surface-vertex %{
  #define CC_SURFACES_VERTEX_MODIFY_CLIP_POS
  vec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)
  {
    return applyJitter(In.clipPos);
  }

  #define CC_SURFACES_VERTEX_MODIFY_UV
  void SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)
  {
    In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;
  #if CC_SURFACES_USE_SECOND_UV
    In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;
  #endif
  }
}%

CCProgram surface-fragment %{
  #if USE_ALBEDO_MAP
    uniform sampler2D albedoMap;
    #pragma define-meta ALBEDO_UV options([v_uv, v_uv1])
  #endif
  #if USE_NORMAL_MAP
    uniform sampler2D normalMap;
    #pragma define-meta NORMAL_UV options([v_uv, v_uv1])
  #endif
  #pragma define-meta DEFAULT_UV options([v_uv, v_uv1])
  #if USE_PBR_MAP
    uniform sampler2D pbrMap;
  #endif
  #if USE_OCCLUSION_MAP
    uniform sampler2D occlusionMap;
  #endif

  #pragma define OCCLUSION_CHANNEL          r
  #pragma define ROUGHNESS_CHANNEL          g
  #pragma define METALLIC_CHANNEL           b
  #pragma define SPECULAR_INTENSITY_CHANNEL a

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r])
  #endif

  #if USE_SUBSURFACE_MAP
    uniform sampler2D subsurfaceMap;
  #endif
  #if USE_THICKNESS_MAP
    uniform sampler2D thicknessMap;
  #endif

  #define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS
  vec4 SurfacesFragmentModifyPBRParams()
  {
    vec4 pbr = pbrParams;
    pbr.x = 1.0;
    pbr.z = 0.0;  // metallic is removed from config
    #if USE_PBR_MAP
      vec4 res = texture(pbrMap, DEFAULT_UV);
      pbr.x = mix(1.0, res.OCCLUSION_CHANNEL, pbrParams.x);
      pbr.y *= res.ROUGHNESS_CHANNEL;
      pbr.w *= res.SPECULAR_INTENSITY_CHANNEL;
    #endif
    #if USE_OCCLUSION_MAP
      pbr.x = mix(1.0, texture(occlusionMap, DEFAULT_UV).OCCLUSION_CHANNEL, pbrParams.x);
    #endif

    #if USE_SUBSURFACE_MAP
      float cavity = texture(subsurfaceMap, FSInput_texcoord).g;
      pbr.w *= cavity;
    #endif
    
    return pbr;
  }

  #define CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS
  vec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)
  {
    return vec4(dualLobeParams.x * roughness, 0.0, 0.0, dualLobeParams.w);
  }
  
  #include <surfaces/data-structures/standard>
  #include <lighting-models/includes/standard>
  
  vec4 GetShadowPosAndDepth(in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)
  {
      vec4 shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);
      vec3 worldPos;
      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
          worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);
      #else
          worldPos = surfaceData.worldPos;
      #endif
      
      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2
          if (cc_mainLitDir.w > 0.0) {
              vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);
              vec4 shadowProjDepthInfo = vec4(0.0);
              vec3 shadowNDCPos;
              bool isExceedShadowMap = true;
              #if CC_DIR_LIGHT_SHADOW_TYPE == 2
                  vec4 shadowProjInfo;
                  vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;
                  isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);
                  GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);
              #endif
              #if CC_DIR_LIGHT_SHADOW_TYPE == 1
                  shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);
                  shadowProjDepthInfo = cc_shadowProjDepthInfo;
                  isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);
              #endif

              shadowPosAndDepth.xy = shadowNDCPos.xy;
              shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);
              shadowPosAndDepth.w = isExceedShadowMap ? shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);
          }
      #endif

      return shadowPosAndDepth;
  }

  #if CC_DRAW_DIFFUSE
  #pragma rate inputDepth pass
  uniform sampler2D inputDepth;
  #include <includes/effect-fucs>
  #endif

  #include <includes/__bug72_patch>
  
  #define CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT
  void SurfacesLightingModifyFinalResult(inout LightingResult result, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, in LightingMiscData miscData)
  {
    float attenuation = lightingData.distAttenuation * lightingData.angleAttenuation;

    #if CC_DRAW_DIFFUSE
      result.directDiffuse = CalculateDirectDiffuse(lightingData, miscData.lightColorAndIntensity) * attenuation;
      #if !CC_FORWARD_ADD
        result.environmentDiffuse = CalculateEnvironmentDiffuse(lightingData, cc_ambientSky.w);
      #endif

      #if CC_USE_SSS
        float thicknessFactor = max(0.00001, scatterParams.x) * (1.0 / dualLobeParams.z);
        float translucencyFactor = max(0.00001, scatterParams.y);
        float thickness = 0.0;
        
        #if USE_THICKNESS_MAP
          thickness = texture(thicknessMap, DEFAULT_UV).a * thicknessFactor;
        #else
          vec4 shadowPosAndDepth = GetShadowPosAndDepth(lightingData, surfaceData);
          if (!((abs(float(shadowPosAndDepth.z) - float(shadowPosAndDepth.w)) < EPSILON) && (abs(float(shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))) {
            float shadowDistance = max(shadowPosAndDepth.w - shadowPosAndDepth.z, 0.0);
            thickness = max(0.0, shadowDistance / thicknessFactor);
          }
        #endif

        vec3 materialDiffuse = surfaceData.baseColor.rgb;  // metallic is 0
        vec3 lightColor = miscData.lightColorAndIntensity.rgb * miscData.lightColorAndIntensity.w;
        
        #define SSS_WRAP_THRESHOLD 0.3
        float wrap = clamp(SSS_WRAP_THRESHOLD - lightingData.NoL, 0.0, 1.0);
        float finalAttenuation = translucencyFactor * attenuation * wrap;
        // beer-Lambert law, per color channel falloff
        vec3 transmittance = exp(-thickness / max(translucencyColor.rgb, vec3(0.001)));
        
        vec3 transmit = finalAttenuation * lightColor * materialDiffuse * transmittance;
        result.directDiffuse += transmit;
      #endif
    
    #endif
    
    #if CC_DRAW_SPECULAR
      result.directSpecular = CalculateDirectSpecular(lightingData, miscData.lightColorAndIntensity) * attenuation;
      #if !CC_FORWARD_ADD
        result.environmentSpecular = CalculateEnvironmentSpecular(lightingData, cc_ambientSky.w);
      #endif
      
    #endif
  }

  #include <advanced/common-functions>
}%

CCProgram standard-vs %{
  precision highp float;
  #include <macro-remapping>
  #include <surfaces/effect-macros/common-macros>
  #include <surfaces/includes/common-vs>
  #include <shared-ubos>
  #include <includes/jitter-vs>
  #include <surface-vertex>
  #include <surfaces/includes/standard-vs>
  #include <shading-entries/main-functions/render-to-scene/vs>
}%

CCProgram shadow-caster-vs %{
  precision highp float;
  #include <macro-remapping>
  #include <surfaces/effect-macros/render-to-shadowmap>
  #include <surfaces/includes/common-vs>
  #include <shared-ubos>
  #include <includes/jitter-vs>
  #include <surface-vertex>
  #include <shading-entries/main-functions/render-to-shadowmap/vs>
}%

CCProgram standard-fs %{
  precision highp float;
  #include <macro-remapping>
  #include <surfaces/effect-macros/common-macros>
  #include <surfaces/includes/common-fs>
  #include <shared-ubos>
  #include <surface-fragment>
  #include <lighting-models/includes/standard>
  #include <surfaces/includes/standard-fs>
  #include <shading-entries/main-functions/render-to-scene/fs>
}%

CCProgram shadow-caster-fs %{
  precision highp float;
  #include <macro-remapping>
  #include <surfaces/effect-macros/render-to-shadowmap>
  #include <surfaces/includes/common-fs>
  #include <shared-ubos>
  #include <surface-fragment>
  #include <shading-entries/main-functions/render-to-shadowmap/fs>
}%

CCProgram reflect-map-fs %{
  precision highp float;
  #include <macro-remapping>
  #include <surfaces/effect-macros/common-macros>
  #include <surfaces/includes/common-fs>
  #include <shared-ubos>
  #include <surface-fragment>
  #include <lighting-models/includes/standard>
  #include <surfaces/includes/standard-fs>
  #include <shading-entries/main-functions/render-to-reflectmap/fs>
}%

CCProgram standard-prepass-vs %{
  #include <includes/prepass-vs>
}%

CCProgram standard-prepass-fs %{
  #include <includes/prepass-fs>
}%
