// Utility effect for pipeline
// Pass 0: tone mapping
// Pass 1: copy
// Pass 2: ssss-blurX
// Pass 3: ssss-blurY

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs-copy
      pass: tonemap
      embeddedMacros: { COPY_TONEMAP: true }
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
    - vert: vs
      frag: fs-copy
      pass: screen-blit
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
    - vert: vs
      frag: fs-ssss-blur
      pass: ssss-blur-x
      embeddedMacros: { SSSS_BLUR_HORIZONTAL: true }
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
    - vert: vs
      frag: fs-ssss-blur
      pass: ssss-blur-y
      embeddedMacros: { SSSS_BLUR_HORIZONTAL: false }
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
}%

CCProgram vs %{
  precision highp float;
  #include <legacy/decode-standard>
  #include <post-process/pipeline>

  out vec2 v_uv;

  void main () {
    StandardVertInput In;
    CCDecode(In);
    FLIP_VULKAN_NDC(In.position);
    gl_Position = In.position;

    v_uv = a_texCoord;
  }
}%

CCProgram fs-copy %{
  precision highp float;

  #if COPY_TONEMAP
    #include <common/color/gamma>
    #include <common/color/tone-mapping>
  #endif

  in vec2 v_uv;

  #pragma rate inputTexture pass
  uniform sampler2D inputTexture;

  layout(location = 0) out vec4 fragColor;

  void main () {
    fragColor = texture(inputTexture, v_uv);

    #if COPY_TONEMAP
      #if CC_USE_FLOAT_OUTPUT
        fragColor.rgb = HDRToLDR(fragColor.rgb);
        fragColor.rgb = LinearToSRGB(fragColor.rgb);
      #endif
    #endif
  }
}%

CCProgram ssss-blur-common %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <common/common-define>
  #include <common/math/number>
  #include <common/data/packing>
  #include <common/color/gamma>
  #include <common/math/coordinates>
  #include <includes/noise>

  #define SSSS_KERNEL_SIZE 25
  #define SSSS_LUT_WIDTH 32.0
  #define SSSS_LUT_HEIGHT 16.0
  #define SSSS_DEPTH_DISCONTINUITY_THRESHOLD 0.05
  #define SSSS_MAX_SCALE 0.333
  
  #pragma rate JitterUBO pass
  uniform JitterUBO {
    vec4 jitterInfo;
  };

  #pragma rate SSSBlurUBO pass
  uniform SSSBlurUBO {
    vec4 sssInfo;      // x = quality, yzw = unused
  };

  #pragma rate colorInput pass
  uniform sampler2D colorInput;
  #pragma rate depthInput pass
  uniform sampler2D depthInput;
  #pragma rate sssKernelLut pass
  uniform sampler2D sssKernelLut;

  #include <includes/effect-fucs>
  
  float getDepthPacked(vec4 pixel) {
    if (pixel.w == 0.0)
      return 0.0;
    return unpackDepth(pixel.rg);
  }

  float getDepthPacked(vec2 uv) {
    vec4 depthPacked = texture(depthInput, uv);
    return getDepthPacked(depthPacked);
  }
  
  vec4 sampleKernelLUT(float kernelSize, int sampleIndex, int profile, int qualityIndex, float dither) {
    int lutRow = qualityIndex * 3 + (profile - 1);
    
    float u = (float(sampleIndex) + 0.5 + dither) * kernelSize;
    float v = (float(lutRow) + 0.5/* + dither*/) / SSSS_LUT_HEIGHT;

    return texture(sssKernelLut, vec2(u, v));
  }

  vec3 textureColor(vec2 uv, vec3 oColor, float oDpeth, float depthBias) {
      if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)
          return oColor.rgb;
      float nDepth = getDepthPacked(uv);
      if (nDepth == 0.0)
        return oColor;
      vec3 nColor = texture(colorInput, uv).rgb;
      return mix(nColor, oColor, smoothstep(0.0, SSSS_DEPTH_DISCONTINUITY_THRESHOLD, abs(oDpeth - nDepth) * depthBias));
  }

  vec4 processBlur(vec2 dir) {
    vec2 gUV = getScreenUV();

    vec4 color = texture(colorInput, gUV);

    vec4 depthPacked = texture(depthInput, gUV);
    float depth = getDepthPacked(depthPacked);

    if (depth == 0.0)
      return color;
    
    float skinInfo = depthPacked.b;
    float sssIntensity, sssProfile;
    unpackSSSInfo(skinInfo, sssProfile, sssIntensity);

    int profile = int(sssProfile);
    if (profile < 1 || sssIntensity == 0.0)
      return color;

    float scatterWorld = max(0.001, sssIntensity) / depthPacked.w;
    float depthRange = (cc_nearFar.y - cc_nearFar.x);
    float worldPos = cc_nearFar.x + depthRange * depth;
    float depthBias = depthRange * SSSS_DEPTH_DISCONTINUITY_THRESHOLD / scatterWorld;

    float projFactor = cc_matProj[0][0];
    vec2 aspect = dir.x > 0.5 ? vec2(projFactor, 0.0) : vec2(0.0, projFactor * (cc_screenSize.y / cc_screenSize.x));
    vec2 sStep = dir * aspect * scatterWorld / worldPos * SSSS_MAX_SCALE;
    
    int qualityIndex = int(sssInfo.x);
    int quality = (qualityIndex == 0) ? 9 : (qualityIndex == 1) ? 17 : 25;
    float kSize = 1.0 / SSSS_LUT_WIDTH;

    vec3 colorBlurred = color.rgb * sampleKernelLUT(kSize, 0, profile, qualityIndex, 0.0).rgb;

    float rnd = ignNoise(gl_FragCoord.xy, jitterInfo.w);
    
    for (int i = 1; i < SSSS_KERNEL_SIZE; i++) {
      if (i >= quality) break;
      
      float dither = sampleKernelLUT(kSize, i, profile, qualityIndex, rnd).a;
      vec2 offset = dither * sStep;
      vec3 c = textureColor(gUV + offset, color.rgb, depth, depthBias);
      c += textureColor(gUV - offset, color.rgb, depth, depthBias);

      colorBlurred += c * sampleKernelLUT(kSize, i, profile, qualityIndex, 0.0).rgb;
    }

    return vec4(colorBlurred, color.a);
  }
}%

CCProgram fs-ssss-blur %{
  precision highp float;
  #include <ssss-blur-common>

  #if SSSS_BLUR_HORIZONTAL
    #define BLUR_DIR vec2(1.0, 0.0)
  #else
    #define BLUR_DIR vec2(0.0, 1.0)
  #endif

  layout(location = 0) out vec4 fragColor;

  void main () {
    fragColor = processBlur(BLUR_DIR);
  }
}%
