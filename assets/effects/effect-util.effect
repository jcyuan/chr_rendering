// Utility effect for pipeline
// Pass 0: tone mapping
// Pass 1: copy
// Pass 2: ssss-blurX
// Pass 3: ssss-blurY
// Pass 4: taa-resolve

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs-copy
      pass: tonemap
      embeddedMacros: { COPY_TONEMAP: true }
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
    - vert: vs
      frag: fs-copy
      pass: screen-blit
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
    - vert: vs
      frag: fs-ssss-blur
      pass: ssss-blur-x
      embeddedMacros: { SSSS_BLUR_HORIZONTAL: true }
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
    - vert: vs
      frag: fs-ssss-blur
      pass: ssss-blur-y
      embeddedMacros: { SSSS_BLUR_HORIZONTAL: false }
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
    - vert: vs
      frag: fs-taa-resolve
      pass: taa-resolve
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: false
        depthWrite: false
}%

CCProgram vs %{
  precision highp float;
  #include <legacy/decode-standard>
  #include <post-process/pipeline>

  out vec2 v_uv;

  void main () {
    StandardVertInput In;
    CCDecode(In);
    FLIP_VULKAN_NDC(In.position);
    gl_Position = In.position;

    v_uv = a_texCoord;
  }
}%

CCProgram fs-copy %{
  precision highp float;

  #if COPY_TONEMAP
    #include <common/color/gamma>
    #include <common/color/tone-mapping>
  #endif

  in vec2 v_uv;

  #pragma rate inputTexture pass
  uniform sampler2D inputTexture;

  layout(location = 0) out vec4 fragColor;

  void main () {
    fragColor = texture(inputTexture, v_uv);

    #if COPY_TONEMAP
      #if CC_USE_FLOAT_OUTPUT
        fragColor.rgb = HDRToLDR(fragColor.rgb);
        fragColor.rgb = LinearToSRGB(fragColor.rgb);
      #endif
    #endif
  }
}%

CCProgram ssss-blur-common %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <common/common-define>
  #include <common/math/number>
  #include <common/data/packing>
  #include <common/color/gamma>
  #include <common/math/coordinates>
  #include <includes/noise>

  #define SSSS_KERNEL_SIZE 25
  #define SSSS_LUT_WIDTH 32.0
  #define SSSS_LUT_HEIGHT 16.0
  #define SSSS_DEPTH_DISCONTINUITY_THRESHOLD 0.05
  #define SSSS_MAX_SCALE 0.333
  
  #pragma rate JitterUBO pass
  uniform JitterUBO {
    vec4 jitterInfo;
  };

  #pragma rate SSSBlurUBO pass
  uniform SSSBlurUBO {
    vec4 sssInfo;      // x = quality, yzw = unused
  };

  #pragma rate colorInput pass
  uniform sampler2D colorInput;
  #pragma rate depthInput pass
  uniform sampler2D depthInput;
  #pragma rate sssKernelLut pass
  uniform sampler2D sssKernelLut;

  #include <includes/effect-fucs>
  
  float getDepthPacked(vec4 pixel) {
    if (pixel.w == 0.0)
      return 0.0;
    return unpackDepth(pixel.rg);
  }

  float getDepthPacked(vec2 uv) {
    vec4 depthPacked = texture(depthInput, uv);
    return getDepthPacked(depthPacked);
  }
  
  vec4 sampleKernelLUT(float kernelSize, int sampleIndex, int profile, int qualityIndex, float dither) {
    int lutRow = qualityIndex * 3 + (profile - 1);
    
    float u = (float(sampleIndex) + 0.5 + dither) * kernelSize;
    float v = (float(lutRow) + 0.5/* + dither*/) / SSSS_LUT_HEIGHT;

    return texture(sssKernelLut, vec2(u, v));
  }

  vec3 textureColor(vec2 uv, vec3 oColor, float oDpeth, float depthBias) {
      if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)
          return oColor.rgb;
      float nDepth = getDepthPacked(uv);
      if (nDepth == 0.0)
        return oColor;
      vec3 nColor = texture(colorInput, uv).rgb;
      return mix(nColor, oColor, smoothstep(0.0, SSSS_DEPTH_DISCONTINUITY_THRESHOLD, abs(oDpeth - nDepth) * depthBias));
  }

  vec4 processBlur(vec2 dir) {
    vec2 gUV = getScreenUV();

    vec4 color = texture(colorInput, gUV);

    vec4 depthPacked = texture(depthInput, gUV);
    float depth = getDepthPacked(depthPacked);

    if (depth == 0.0)
      return color;
    
    float skinInfo = depthPacked.b;
    float sssIntensity, sssProfile;
    unpackSSSInfo(skinInfo, sssProfile, sssIntensity);

    int profile = int(sssProfile);
    if (profile < 1 || sssIntensity == 0.0)
      return color;

    float scatterWorld = max(0.001, sssIntensity) / depthPacked.w;
    float depthRange = (cc_nearFar.y - cc_nearFar.x);
    float worldPos = cc_nearFar.x + depthRange * depth;
    float depthBias = depthRange * SSSS_DEPTH_DISCONTINUITY_THRESHOLD / scatterWorld;

    float projFactor = cc_matProj[0][0];
    vec2 aspect = dir.x > 0.5 ? vec2(projFactor, 0.0) : vec2(0.0, projFactor * (cc_screenSize.y / cc_screenSize.x));
    vec2 sStep = dir * aspect * scatterWorld / worldPos * SSSS_MAX_SCALE;
    
    int qualityIndex = int(sssInfo.x);
    int quality = (qualityIndex == 0) ? 9 : (qualityIndex == 1) ? 17 : 25;
    float kSize = 1.0 / SSSS_LUT_WIDTH;

    vec3 colorBlurred = color.rgb * sampleKernelLUT(kSize, 0, profile, qualityIndex, 0.0).rgb;

    float rnd = ignNoise(gl_FragCoord.xy, jitterInfo.w);
    
    for (int i = 1; i < SSSS_KERNEL_SIZE; i++) {
      if (i >= quality) break;
      
      float dither = sampleKernelLUT(kSize, i, profile, qualityIndex, rnd).a;
      vec2 offset = dither * sStep;
      vec3 c = textureColor(gUV + offset, color.rgb, depth, depthBias);
      c += textureColor(gUV - offset, color.rgb, depth, depthBias);

      colorBlurred += c * sampleKernelLUT(kSize, i, profile, qualityIndex, 0.0).rgb;
    }

    return vec4(colorBlurred, color.a);
  }
}%

CCProgram fs-ssss-blur %{
  precision highp float;
  #include <ssss-blur-common>

  #if SSSS_BLUR_HORIZONTAL
    #define BLUR_DIR vec2(1.0, 0.0)
  #else
    #define BLUR_DIR vec2(0.0, 1.0)
  #endif

  layout(location = 0) out vec4 fragColor;

  void main () {
    fragColor = processBlur(BLUR_DIR);
  }
}%

CCProgram fs-taa-resolve %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <common/common-define>
  #include <common/math/coordinates>
  #include <includes/effect-fucs>

  #define TAA_MODE_FIRST   0.0
  #define TAA_MODE_TAA     1.0
  #define TAA_MODE_SSAA    2.0

  #pragma rate TAAUBO pass
  uniform TAAUBO {
    vec4 taaMotion0;
    vec4 taaMotion1;
    vec4 taaMotion2;
    vec4 taaMotion3;
    vec4 taaParams;
  };

  #pragma rate JitterUBO pass
  uniform JitterUBO {
    vec4 jitterInfo;
  };

  #pragma rate currentInput pass
  uniform sampler2D currentInput;
  #pragma rate historyInput pass
  uniform sampler2D historyInput;
  #pragma rate depthInput pass
  uniform sampler2D depthInput;

  float getLuminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
  }

  float sampleDepth(vec2 uv) {
    vec4 depthSample = texture(depthInput, uv);
    if (depthSample.w == 0.0)
      return 0.0;
    return unpackDepth(depthSample.rg);
  }

  vec3 closestFragment(vec2 uv, vec2 texelSize) {
    float d;
    vec2 size = 2.0 * texelSize;
    vec3 dmin = vec3(0.0, 0.0, 0.0);

    dmin.z = sampleDepth(uv);
    d = sampleDepth(uv + vec2(-size.x,  size.y)); if (d > dmin.z) dmin = vec3(-size.x,  size.y, d);
    d = sampleDepth(uv + vec2( size.x,  size.y)); if (d > dmin.z) dmin = vec3( size.x,  size.y, d);
    d = sampleDepth(uv + vec2(-size.x, -size.y)); if (d > dmin.z) dmin = vec3(-size.x, -size.y, d);
    d = sampleDepth(uv + vec2( size.x, -size.y)); if (d > dmin.z) dmin = vec3( size.x, -size.y, d);

    return vec3(uv + dmin.xy, dmin.z);
  }

  vec3 reconstructViewPos(vec2 uv, float linearDepth) {
    float viewZ = -(cc_nearFar.x + (cc_nearFar.y - cc_nearFar.x) * linearDepth);
    vec2 ndc = uv * 2.0 - 1.0;
    float viewX = ndc.x * (-viewZ) / cc_matProj[0][0];
    float viewY = ndc.y * (-viewZ) / cc_matProj[1][1];
    return vec3(viewX, viewY, viewZ);
  }

  vec2 computeSSVelocity(vec2 pixelPos, vec3 vsPos) {
    mat4 motionMatrix = mat4(taaMotion0, taaMotion1, taaMotion2, taaMotion3);
    vec4 prevClip = motionMatrix * vec4(vsPos, 1.0);
    vec2 ndcPrev = prevClip.xy / prevClip.w;

    if (ndcPrev.x >= 1.0 || ndcPrev.x <= -1.0 ||
        ndcPrev.y >= 1.0 || ndcPrev.y <= -1.0)
      return vec2(0.0);

    vec2 ndcCurrent = pixelPos * 2.0 - 1.0;
    return 0.5 * (ndcCurrent - ndcPrev);
  }

  vec4 clipAABB(vec4 aabbMin, vec4 aabbMax, vec4 color) {
    const float eps = 0.00000001;
    vec4 center = 0.5 * (aabbMax + aabbMin);
    vec4 extents = 0.5 * (aabbMax - aabbMin) + eps;
    vec4 offset = color - center;
    vec4 ts = abs(offset / extents);
    float t = max(max(ts.r, ts.g), max(ts.b, ts.a));
    return center + offset / max(1.0, t);
  }

  vec4 taaResolve(vec2 ssVel, vec2 texelSize) {
    vec2 uv = getScreenUV();

    vec4 tl = texture(currentInput, uv + vec2(-texelSize.x,  texelSize.y));
    vec4 t  = texture(currentInput, uv + vec2(         0.0,  texelSize.y));
    vec4 tr = texture(currentInput, uv + vec2( texelSize.x,  texelSize.y));

    vec4 ml = texture(currentInput, uv + vec2(-texelSize.x, 0.0));
    vec4 m  = texture(currentInput, uv);
    vec4 mr = texture(currentInput, uv + vec2( texelSize.x, 0.0));

    vec4 bl = texture(currentInput, uv + vec2(-texelSize.x, -texelSize.y));
    vec4 b  = texture(currentInput, uv + vec2(         0.0, -texelSize.y));
    vec4 br = texture(currentInput, uv + vec2( texelSize.x, -texelSize.y));

    vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * m;
    m += (m - (corners * 0.166667)) * 2.718282 * 0.3;
    m = max(vec4(0.0), m);

    vec4 cmin5 = min(mr, min(m, min(ml, min(t, b))));
    vec4 cmin = min(cmin5, min(tl, min(tr, min(bl, br))));

    vec4 cmax5 = max(mr, max(m, max(ml, max(t, b))));
    vec4 cmax = max(cmax5, max(tl, max(tr, max(bl, br))));

    cmin = 0.5 * (cmin + cmin5);
    cmax = 0.5 * (cmax + cmax5);

    vec4 previousColor = texture(historyInput, uv - ssVel);
    previousColor = clipAABB(cmin, cmax, previousColor);

    float lum0 = getLuminance(m.rgb);
    float lum1 = getLuminance(previousColor.rgb);
    float diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));
    float unbiasedWeight = 1.0 - diff;
    // feedback = (1 - 1/8.3), (1 - 1/33.5)
    float feedback = mix(0.88, 0.97, unbiasedWeight * unbiasedWeight);

    return mix(m, previousColor, feedback);
  }

  vec4 superSample() {
    vec2 uv = getScreenUV();
    vec4 current = texture(currentInput, uv);
    vec4 history = texture(historyInput, uv);
    float blendFactor = taaParams.y;
    return mix(current, history, 1.0 - blendFactor);
  }

  layout(location = 0) out vec4 fragColor;

  void main () {
    vec2 uv = getScreenUV();
    float mode = taaParams.x;

    if (mode == TAA_MODE_FIRST) {
      fragColor = texture(currentInput, uv);
      return;
    }

    if (mode == TAA_MODE_SSAA) {
      fragColor = superSample();
      return;
    }

    vec2 texelSize = cc_screenSize.zw;
    vec3 closest = closestFragment(uv, texelSize);

    if (closest.z == 0.0) {
      vec2 unjitteredUV = uv - jitterInfo.xy * texelSize * 0.5;
      fragColor = texture(currentInput, unjitteredUV);
      return;
    }

    vec3 viewPos = reconstructViewPos(closest.xy, closest.z);
    vec2 ssVel = computeSSVelocity(closest.xy, viewPos);

    fragColor = taaResolve(ssVel, texelSize);
  }
}%
